<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>OSS-7: Open Source Stack for DASH7 Alliance Protocol: Uart_driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OSS-7: Open Source Stack for DASH7 Alliance Protocol
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__uart__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Uart_driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:fsl__uart__driver_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fsl__uart__driver_8h.html">fsl_uart_driver.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_uart_state.html">UartState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the UART driver.  <a href="struct_uart_state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_uart_user_config.html">UartUserConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User configuration structure for the UART driver.  <a href="struct_uart_user_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab83bb42b50f860484cac188318d92e14"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gab83bb42b50f860484cac188318d92e14">uart_rx_callback_t</a>) (uint32_t instance, void *uartState)</td></tr>
<tr class="memdesc:gab83bb42b50f860484cac188318d92e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART receive callback function type.  <a href="#gab83bb42b50f860484cac188318d92e14">More...</a><br /></td></tr>
<tr class="separator:gab83bb42b50f860484cac188318d92e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78230f4c7482a4bdd3bc14f9e1a9fa98"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga78230f4c7482a4bdd3bc14f9e1a9fa98">uart_tx_callback_t</a>) (uint32_t instance, void *uartState)</td></tr>
<tr class="memdesc:ga78230f4c7482a4bdd3bc14f9e1a9fa98"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transmit callback function type.  <a href="#ga78230f4c7482a4bdd3bc14f9e1a9fa98">More...</a><br /></td></tr>
<tr class="separator:ga78230f4c7482a4bdd3bc14f9e1a9fa98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7c3fe8f98e0049dc551b4af4423abc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_uart_state.html">UartState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaae7c3fe8f98e0049dc551b4af4423abc">uart_state_t</a></td></tr>
<tr class="memdesc:gaae7c3fe8f98e0049dc551b4af4423abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime state of the UART driver.  <a href="#gaae7c3fe8f98e0049dc551b4af4423abc">More...</a><br /></td></tr>
<tr class="separator:gaae7c3fe8f98e0049dc551b4af4423abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f8c2ac4258d4aa6380b095c3a40ee75"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_uart_user_config.html">UartUserConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga4f8c2ac4258d4aa6380b095c3a40ee75">uart_user_config_t</a></td></tr>
<tr class="memdesc:ga4f8c2ac4258d4aa6380b095c3a40ee75"><td class="mdescLeft">&#160;</td><td class="mdescRight">User configuration structure for the UART driver.  <a href="#ga4f8c2ac4258d4aa6380b095c3a40ee75">More...</a><br /></td></tr>
<tr class="separator:ga4f8c2ac4258d4aa6380b095c3a40ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga15fcdfe0373578297c655dc4c8dc499f"><td class="memItemLeft" align="right" valign="top">UART_Type *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga15fcdfe0373578297c655dc4c8dc499f">g_uartBase</a> [UART_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga15fcdfe0373578297c655dc4c8dc499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of base addresses for UART instances.  <a href="#ga15fcdfe0373578297c655dc4c8dc499f">More...</a><br /></td></tr>
<tr class="separator:ga15fcdfe0373578297c655dc4c8dc499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d508e1f9a8be24c55e3b9429c9c74d"><td class="memItemLeft" align="right" valign="top">const IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga89d508e1f9a8be24c55e3b9429c9c74d">g_uartRxTxIrqId</a> [UART_INSTANCE_COUNT]</td></tr>
<tr class="memdesc:ga89d508e1f9a8be24c55e3b9429c9c74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table to save UART IRQ enumeration numbers defined in the CMSIS header file.  <a href="#ga89d508e1f9a8be24c55e3b9429c9c74d">More...</a><br /></td></tr>
<tr class="separator:ga89d508e1f9a8be24c55e3b9429c9c74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UART Interrupt Driver</h2></td></tr>
<tr class="memitem:ga588680e1275ab5b98aacfbb90aee8f99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga588680e1275ab5b98aacfbb90aee8f99">UART_DRV_Init</a> (uint32_t instance, <a class="el" href="group__uart__driver.html#gaae7c3fe8f98e0049dc551b4af4423abc">uart_state_t</a> *uartStatePtr, const <a class="el" href="group__uart__driver.html#ga4f8c2ac4258d4aa6380b095c3a40ee75">uart_user_config_t</a> *uartUserConfig)</td></tr>
<tr class="memdesc:ga588680e1275ab5b98aacfbb90aee8f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an UART instance for operation.  <a href="#ga588680e1275ab5b98aacfbb90aee8f99">More...</a><br /></td></tr>
<tr class="separator:ga588680e1275ab5b98aacfbb90aee8f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a444cd862937003328e8e320a18457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gab0a444cd862937003328e8e320a18457">UART_DRV_Deinit</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gab0a444cd862937003328e8e320a18457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuts down the UART by disabling interrupts and the transmitter/receiver.  <a href="#gab0a444cd862937003328e8e320a18457">More...</a><br /></td></tr>
<tr class="separator:gab0a444cd862937003328e8e320a18457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46806b62148493d3841610b441346408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__driver.html#gab83bb42b50f860484cac188318d92e14">uart_rx_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga46806b62148493d3841610b441346408">UART_DRV_InstallRxCallback</a> (uint32_t instance, <a class="el" href="group__uart__driver.html#gab83bb42b50f860484cac188318d92e14">uart_rx_callback_t</a> function, uint8_t *rxBuff, void *callbackParam, bool alwaysEnableRxIrq)</td></tr>
<tr class="memdesc:ga46806b62148493d3841610b441346408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the callback function for the UART receive.  <a href="#ga46806b62148493d3841610b441346408">More...</a><br /></td></tr>
<tr class="separator:ga46806b62148493d3841610b441346408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4828e0398d6e281e26d595ec3dbfde1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__driver.html#ga78230f4c7482a4bdd3bc14f9e1a9fa98">uart_tx_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaa4828e0398d6e281e26d595ec3dbfde1">UART_DRV_InstallTxCallback</a> (uint32_t instance, <a class="el" href="group__uart__driver.html#ga78230f4c7482a4bdd3bc14f9e1a9fa98">uart_tx_callback_t</a> function, uint8_t *txBuff, void *callbackParam)</td></tr>
<tr class="memdesc:gaa4828e0398d6e281e26d595ec3dbfde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Installs the callback function for the UART transmit.  <a href="#gaa4828e0398d6e281e26d595ec3dbfde1">More...</a><br /></td></tr>
<tr class="separator:gaa4828e0398d6e281e26d595ec3dbfde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2278d7864b7381973f5cf45e63f1248b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga2278d7864b7381973f5cf45e63f1248b">UART_DRV_SendDataBlocking</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize, uint32_t timeout)</td></tr>
<tr class="memdesc:ga2278d7864b7381973f5cf45e63f1248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends (transmits) data out through the UART module using a blocking method.  <a href="#ga2278d7864b7381973f5cf45e63f1248b">More...</a><br /></td></tr>
<tr class="separator:ga2278d7864b7381973f5cf45e63f1248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eae402145cd798e8173148aa50dc5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga0eae402145cd798e8173148aa50dc5a4">UART_DRV_SendData</a> (uint32_t instance, const uint8_t *txBuff, uint32_t txSize)</td></tr>
<tr class="memdesc:ga0eae402145cd798e8173148aa50dc5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends (transmits) data through the UART module using a non-blocking method.  <a href="#ga0eae402145cd798e8173148aa50dc5a4">More...</a><br /></td></tr>
<tr class="separator:ga0eae402145cd798e8173148aa50dc5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167b2ec289daf07812e0cd72dec5fe72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga167b2ec289daf07812e0cd72dec5fe72">UART_DRV_GetTransmitStatus</a> (uint32_t instance, uint32_t *bytesRemaining)</td></tr>
<tr class="memdesc:ga167b2ec289daf07812e0cd72dec5fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous UART transmit has finished.  <a href="#ga167b2ec289daf07812e0cd72dec5fe72">More...</a><br /></td></tr>
<tr class="separator:ga167b2ec289daf07812e0cd72dec5fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830585043a238d7226335d90c7bce1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga830585043a238d7226335d90c7bce1e4">UART_DRV_AbortSendingData</a> (uint32_t instance)</td></tr>
<tr class="memdesc:ga830585043a238d7226335d90c7bce1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous UART transmission early.  <a href="#ga830585043a238d7226335d90c7bce1e4">More...</a><br /></td></tr>
<tr class="separator:ga830585043a238d7226335d90c7bce1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54d95d43b1a338eb16b16c424f665c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gae54d95d43b1a338eb16b16c424f665c0">UART_DRV_ReceiveDataBlocking</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize, uint32_t timeout)</td></tr>
<tr class="memdesc:gae54d95d43b1a338eb16b16c424f665c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets (receives) data from the UART module using a blocking method.  <a href="#gae54d95d43b1a338eb16b16c424f665c0">More...</a><br /></td></tr>
<tr class="separator:gae54d95d43b1a338eb16b16c424f665c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cca3b5bb78a8d7ff120762e1667c144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga4cca3b5bb78a8d7ff120762e1667c144">UART_DRV_ReceiveData</a> (uint32_t instance, uint8_t *rxBuff, uint32_t rxSize)</td></tr>
<tr class="memdesc:ga4cca3b5bb78a8d7ff120762e1667c144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets (receives) data from the UART module using a non-blocking method.  <a href="#ga4cca3b5bb78a8d7ff120762e1667c144">More...</a><br /></td></tr>
<tr class="separator:ga4cca3b5bb78a8d7ff120762e1667c144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83d6037e5223abbe7d2e29cfbe48d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaa83d6037e5223abbe7d2e29cfbe48d75">UART_DRV_GetReceiveStatus</a> (uint32_t instance, uint32_t *bytesRemaining)</td></tr>
<tr class="memdesc:gaa83d6037e5223abbe7d2e29cfbe48d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the previous UART receive is complete.  <a href="#gaa83d6037e5223abbe7d2e29cfbe48d75">More...</a><br /></td></tr>
<tr class="separator:gaa83d6037e5223abbe7d2e29cfbe48d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf501580a6eb4f3cfde1e104bebecc40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaf501580a6eb4f3cfde1e104bebecc40d">UART_DRV_AbortReceivingData</a> (uint32_t instance)</td></tr>
<tr class="memdesc:gaf501580a6eb4f3cfde1e104bebecc40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates an asynchronous UART receive early.  <a href="#gaf501580a6eb4f3cfde1e104bebecc40d">More...</a><br /></td></tr>
<tr class="separator:gaf501580a6eb4f3cfde1e104bebecc40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gab83bb42b50f860484cac188318d92e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  uart_rx_callback_t) (uint32_t instance, void *uartState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART receive callback function type. </p>

</div>
</div>
<a class="anchor" id="gaae7c3fe8f98e0049dc551b4af4423abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_uart_state.html">UartState</a>  <a class="el" href="group__uart__driver.html#gaae7c3fe8f98e0049dc551b4af4423abc">uart_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime state of the UART driver. </p>
<p>This structure holds data that are used by the UART peripheral driver to communicate between the transfer function and the interrupt handler. The interrupt handler also uses this information to keep track of its progress. The user passes in the memory for the run-time state structure and the UART driver fills out the members. </p>

</div>
</div>
<a class="anchor" id="ga78230f4c7482a4bdd3bc14f9e1a9fa98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  uart_tx_callback_t) (uint32_t instance, void *uartState)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART transmit callback function type. </p>

</div>
</div>
<a class="anchor" id="ga4f8c2ac4258d4aa6380b095c3a40ee75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_uart_user_config.html">UartUserConfig</a>  <a class="el" href="group__uart__driver.html#ga4f8c2ac4258d4aa6380b095c3a40ee75">uart_user_config_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User configuration structure for the UART driver. </p>
<p>Use an instance of this structure with the <a class="el" href="group__uart__driver.html#ga588680e1275ab5b98aacfbb90aee8f99" title="Initializes an UART instance for operation. ">UART_DRV_Init()</a>function. This enables configuration of the most common settings of the UART peripheral with a single function call. Settings include: UART baud rate, UART parity mode: disabled (default), or even or odd, the number of stop bits, and the number of bits per data word. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf501580a6eb4f3cfde1e104bebecc40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_AbortReceivingData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates an asynchronous UART receive early. </p>
<p>During an a-sync UART receive, the user can terminate the receive early if the receive is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the aborting success or not. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_Success</td><td>The receive was successful. </td></tr>
    <tr><td class="paramname">kStatus_UART_NoTransmitInProgress</td><td>No receive is currently in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga830585043a238d7226335d90c7bce1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_AbortSendingData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates an asynchronous UART transmission early. </p>
<p>During an a-sync UART transmission, the user can terminate the transmission early if the transmission is still in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the aborting success or not. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_Success</td><td>The transmit was successful. </td></tr>
    <tr><td class="paramname">kStatus_UART_NoTransmitInProgress</td><td>No transmission is currently in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab0a444cd862937003328e8e320a18457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_Deinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuts down the UART by disabling interrupts and the transmitter/receiver. </p>
<p>This function disables the UART interrupts, the transmitter and receiver, and flushes the FIFOs (for modules that support FIFOs).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART instance number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa83d6037e5223abbe7d2e29cfbe48d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_GetReceiveStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesRemaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the previous UART receive is complete. </p>
<p>When performing an a-sync receive, call this function to find out the state of the current receive progress: in progress (or busy) or complete (success). In addition, if the receive is still in progress, the user can obtain the number of words that have been currently received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
    <tr><td class="paramname">bytesRemaining</td><td>A pointer to a value that is filled in with the number of bytes which still need to be received in the active transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The receive status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_Success</td><td>The receive has completed successfully. </td></tr>
    <tr><td class="paramname">kStatus_UART_RxBusy</td><td>The receive is still in progress. <em>bytesReceived</em> is filled with the number of bytes which are received up to that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga167b2ec289daf07812e0cd72dec5fe72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_GetTransmitStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytesRemaining</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the previous UART transmit has finished. </p>
<p>When performing an a-sync transmit, call this function to ascertain the state of the current transmission: in progress (or busy) or complete (success). If the transmission is still in progress, the user can obtain the number of words that have been transferred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
    <tr><td class="paramname">bytesRemaining</td><td>A pointer to a value that is filled in with the number of bytes that are remaining in the active transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transmit status. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_Success</td><td>The transmit has completed successfully. </td></tr>
    <tr><td class="paramname">kStatus_UART_TxBusy</td><td>The transmit is still in progress. <em>bytesTransmitted</em> is filled with the number of bytes which are transmitted up to that point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga588680e1275ab5b98aacfbb90aee8f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_Init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#gaae7c3fe8f98e0049dc551b4af4423abc">uart_state_t</a> *&#160;</td>
          <td class="paramname"><em>uartStatePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__uart__driver.html#ga4f8c2ac4258d4aa6380b095c3a40ee75">uart_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>uartUserConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an UART instance for operation. </p>
<p>This function initializes the run-time state structure to keep track of the on-going transfers, un-gates the clock to the UART module, initializes the module to user-defined settings and default settings, configures the IRQ state structure, and enables the module-level interrupt to the core, and the UART module transmitter and receiver. This example shows how to set up the uart_state_t and the uart_user_config_t parameters and how to call the UART_DRV_Init function by passing in these parameters: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;uart_user_config_t uartConfig;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;uartConfig.baudRate = 9600;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;uartConfig.bitCountPerChar = kUart8BitsPerChar;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;uartConfig.parityMode = kUartParityDisabled;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;uartConfig.stopBitCount = kUartOneStopBit;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;uart_state_t uartState;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;UART_DRV_Init(instance, &amp;uartState, &amp;uartConfig);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART instance number. </td></tr>
    <tr><td class="paramname">uartStatePtr</td><td>A pointer to the UART driver state structure memory. The user passes in the memory for this run-time state structure. The UART driver populates the members. The run-time state structure keeps track of the current transfer in progress. </td></tr>
    <tr><td class="paramname">uartUserConfig</td><td>The user configuration structure of type uart_user_config_t. The user populates the members of this structure and passes the pointer of this structure to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46806b62148493d3841610b441346408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__driver.html#gab83bb42b50f860484cac188318d92e14">uart_rx_callback_t</a> UART_DRV_InstallRxCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#gab83bb42b50f860484cac188318d92e14">uart_rx_callback_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alwaysEnableRxIrq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the callback function for the UART receive. </p>
<dl class="section note"><dt>Note</dt><dd>After a callback is installed, it bypasses part of the UART IRQHandler logic. So, the callback needs to handle the indexes of rxBuff, rxSize.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART instance number. </td></tr>
    <tr><td class="paramname">function</td><td>The UART receive callback function. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>The receive buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The UART receive callback parameter pointer. </td></tr>
    <tr><td class="paramname">alwaysEnableRxIrq</td><td>Whether always enable receive IRQ or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Former UART receive callback function pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4828e0398d6e281e26d595ec3dbfde1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__driver.html#ga78230f4c7482a4bdd3bc14f9e1a9fa98">uart_tx_callback_t</a> UART_DRV_InstallTxCallback </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#ga78230f4c7482a4bdd3bc14f9e1a9fa98">uart_tx_callback_t</a>&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Installs the callback function for the UART transmit. </p>
<dl class="section note"><dt>Note</dt><dd>After a callback is installed, it bypasses part of the UART IRQHandler logic. Therefore, the callback needs to handle the txBuff and txSize indexes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART instance number. </td></tr>
    <tr><td class="paramname">function</td><td>The UART transmit callback function. </td></tr>
    <tr><td class="paramname">txBuff</td><td>The transmit buffer used inside IRQHandler. This buffer must be kept as long as the callback is alive. </td></tr>
    <tr><td class="paramname">callbackParam</td><td>The UART transmit callback parameter pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Former UART transmit callback function pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4cca3b5bb78a8d7ff120762e1667c144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_ReceiveData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets (receives) data from the UART module using a non-blocking method. </p>
<p>A non-blocking (also known as synchronous) function means that the function returns immediately after initiating the receive function. The application has to get the receive status to see when the receive is complete. In other words, after calling non-blocking (asynchronous) get function, the application must get the receive status to check if receive is completed or not. The asynchronous method of transmitting and receiving allows the UART to perform a full duplex operation (simultaneously transmit and receive).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>A pointer to the buffer containing 8-bit read data chars received. </td></tr>
    <tr><td class="paramname">rxSize</td><td>The number of bytes to receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="gae54d95d43b1a338eb16b16c424f665c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_ReceiveDataBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets (receives) data from the UART module using a blocking method. </p>
<p>A blocking (also known as synchronous) function means that the function does not return until the receive is complete. This blocking function sends data through the UART port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>A pointer to the buffer containing 8-bit read data chars received. </td></tr>
    <tr><td class="paramname">rxSize</td><td>The number of bytes to receive. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout value for RTOS abstraction sync control in milliseconds (ms). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0eae402145cd798e8173148aa50dc5a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_SendData </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends (transmits) data through the UART module using a non-blocking method. </p>
<p>A non-blocking (also known as synchronous) function means that the function returns immediately after initiating the transmit function. The application has to get the transmit status to see when the transmit is complete. In other words, after calling non-blocking (asynchronous) send function, the application must get the transmit status to check if transmit is complete. The asynchronous method of transmitting and receiving allows the UART to perform a full duplex operation (simultaneously transmit and receive).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART module base address. </td></tr>
    <tr><td class="paramname">txBuff</td><td>A pointer to the source buffer containing 8-bit data chars to send. </td></tr>
    <tr><td class="paramname">txSize</td><td>The number of bytes to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2278d7864b7381973f5cf45e63f1248b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__uart__hal.html#ga90effa380d181d660c1bb449977e1535">uart_status_t</a> UART_DRV_SendDataBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends (transmits) data out through the UART module using a blocking method. </p>
<p>A blocking (also known as synchronous) function means that the function does not return until the transmit is complete. This blocking function is used to send data through the UART port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The UART instance number. </td></tr>
    <tr><td class="paramname">txBuff</td><td>A pointer to the source buffer containing 8-bit data chars to send. </td></tr>
    <tr><td class="paramname">txSize</td><td>The number of bytes to send. </td></tr>
    <tr><td class="paramname">timeout</td><td>A timeout value for RTOS abstraction sync control in milliseconds (ms). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or kStatus_UART_Success. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga15fcdfe0373578297c655dc4c8dc499f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UART_Type* const g_uartBase[UART_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Table of base addresses for UART instances. </p>

</div>
</div>
<a class="anchor" id="ga89d508e1f9a8be24c55e3b9429c9c74d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const IRQn_Type g_uartRxTxIrqId[UART_INSTANCE_COUNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Table to save UART IRQ enumeration numbers defined in the CMSIS header file. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jan 17 2016 07:39:13 for OSS-7: Open Source Stack for DASH7 Alliance Protocol by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
